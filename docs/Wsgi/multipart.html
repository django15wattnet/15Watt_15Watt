<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Wsgi.multipart API documentation</title>
<meta name="description" content="Parser for multipart/form-data
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Wsgi.multipart</code></h1>
</header>
<section id="section-intro">
<h2 id="parser-for-multipartform-data">Parser for multipart/form-data</h2>
<p>This module provides a parser for the multipart/form-data format. It can read
from a file, a socket or a WSGI environment. The parser can be used to replace
cgi.FieldStorage to work around its limitations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Parser for multipart/form-data
------------------------------

This module provides a parser for the multipart/form-data format. It can read
from a file, a socket or a WSGI environment. The parser can be used to replace
cgi.FieldStorage to work around its limitations.
&#34;&#34;&#34;


__author__ = &#34;Marcel Hellkamp&#34;
__version__ = &#34;0.2.4&#34;
__license__ = &#34;MIT&#34;
__all__ = [&#34;MultipartError&#34;, &#34;MultipartParser&#34;, &#34;MultipartPart&#34;, &#34;parse_form_data&#34;]


import re
import sys
from io import BytesIO
from tempfile import TemporaryFile
from urllib.parse import parse_qs
from wsgiref.headers import Headers
from collections.abc import MutableMapping as DictMixin


##############################################################################
################################ Helper &amp; Misc ###############################
##############################################################################
# Some of these were copied from bottle: https://bottlepy.org


# ---------
# MultiDict
# ---------


class MultiDict(DictMixin):
    &#34;&#34;&#34; A dict that remembers old values for each key.
        HTTP headers may repeat with differing values,
        such as Set-Cookie. We need to remember all
        values.
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self.dict = dict()
        for k, v in dict(*args, **kwargs).items():
            self[k] = v

    def __len__(self):
        return len(self.dict)

    def __iter__(self):
        return iter(self.dict)

    def __contains__(self, key):
        return key in self.dict

    def __delitem__(self, key):
        del self.dict[key]

    def keys(self):
        return self.dict.keys()

    def __getitem__(self, key):
        return self.get(key, KeyError, -1)

    def __setitem__(self, key, value):
        self.append(key, value)

    def append(self, key, value):
        self.dict.setdefault(key, []).append(value)

    def replace(self, key, value):
        self.dict[key] = [value]

    def getall(self, key):
        return self.dict.get(key) or []

    def get(self, key, default=None, index=-1):
        if key not in self.dict and default != KeyError:
            return [default][index]

        return self.dict[key][index]

    def iterallitems(self):
        for key, values in self.dict.items():
            for value in values:
                yield key, value


def to_bytes(data, enc=&#34;utf8&#34;):
    if isinstance(data, str):
        data = data.encode(enc)

    return data


def copy_file(stream, target, maxread=-1, buffer_size=2 ** 16):
    &#34;&#34;&#34; Read from :stream and write to :target until :maxread or EOF. &#34;&#34;&#34;
    size, read = 0, stream.read

    while True:
        to_read = buffer_size if maxread &lt; 0 else min(buffer_size, maxread - size)
        part = read(to_read)

        if not part:
            return size

        target.write(part)
        size += len(part)


# -------------
# Header Parser
# -------------


_special = re.escape(&#39;()&lt;&gt;@,;:&#34;\\/[]?={} \t&#39;)
_re_special = re.compile(r&#39;[%s]&#39; % _special)
_quoted_string = r&#39;&#34;(?:\\.|[^&#34;])*&#34;&#39;  # Quoted string
_value = r&#39;(?:[^%s]+|%s)&#39; % (_special, _quoted_string)  # Save or quoted string
_option = r&#39;(?:;|^)\s*([^%s]+)\s*=\s*(%s)&#39; % (_special, _value)
_re_option = re.compile(_option)  # key=value part of an Content-Type like header


def header_quote(val):
    if not _re_special.search(val):
        return val

    return &#39;&#34;&#39; + val.replace(&#34;\\&#34;, &#34;\\\\&#34;).replace(&#39;&#34;&#39;, &#39;\\&#34;&#39;) + &#39;&#34;&#39;


def header_unquote(val, filename=False):
    if val[0] == val[-1] == &#39;&#34;&#39;:
        val = val[1:-1]

        if val[1:3] == &#34;:\\&#34; or val[:2] == &#34;\\\\&#34;:
            val = val.split(&#34;\\&#34;)[-1]  # fix ie6 bug: full path --&gt; filename

        return val.replace(&#34;\\\\&#34;, &#34;\\&#34;).replace(&#39;\\&#34;&#39;, &#39;&#34;&#39;)

    return val


def parse_options_header(header, options=None):
    if &#34;;&#34; not in header:
        return header.lower().strip(), {}

    content_type, tail = header.split(&#34;;&#34;, 1)
    options = options or {}

    for match in _re_option.finditer(tail):
        key = match.group(1).lower()
        value = header_unquote(match.group(2), key == &#34;filename&#34;)
        options[key] = value

    return content_type, options


##############################################################################
################################## Multipart #################################
##############################################################################


class MultipartError(ValueError):
    pass


class MultipartParser(object):
    def __init__(
        self,
        stream,
        boundary,
        content_length=-1,
        disk_limit=2 ** 30,
        mem_limit=2 ** 20,
        memfile_limit=2 ** 18,
        buffer_size=2 ** 16,
        charset=&#34;latin1&#34;,
    ):
        &#34;&#34;&#34; Parse a multipart/form-data byte stream. This object is an iterator
            over the parts of the message.

            :param stream: A file-like stream. Must implement ``.read(size)``.
            :param boundary: The multipart boundary as a byte string.
            :param content_length: The maximum number of bytes to read.
        &#34;&#34;&#34;
        self.stream = stream
        self.boundary = boundary
        self.content_length = content_length
        self.disk_limit = disk_limit
        self.memfile_limit = memfile_limit
        self.mem_limit = min(mem_limit, self.disk_limit)
        self.buffer_size = min(buffer_size, self.mem_limit)
        self.charset = charset

        if self.buffer_size - 6 &lt; len(boundary):  # &#34;--boundary--\r\n&#34;
            raise MultipartError(&#34;Boundary does not fit into buffer_size.&#34;)

        self._done = []
        self._part_iter = None

    def __iter__(self):
        &#34;&#34;&#34; Iterate over the parts of the multipart message. &#34;&#34;&#34;
        if not self._part_iter:
            self._part_iter = self._iterparse()

        for part in self._done:
            yield part

        for part in self._part_iter:
            self._done.append(part)
            yield part

    def parts(self):
        &#34;&#34;&#34; Returns a list with all parts of the multipart message. &#34;&#34;&#34;
        return list(self)

    def get(self, name, default=None):
        &#34;&#34;&#34; Return the first part with that name or a default value (None). &#34;&#34;&#34;
        for part in self:
            if name == part.name:
                return part

        return default

    def get_all(self, name):
        &#34;&#34;&#34; Return a list of parts with that name. &#34;&#34;&#34;
        return [p for p in self if p.name == name]

    def _lineiter(self):
        &#34;&#34;&#34; Iterate over a binary file-like object line by line. Each line is
            returned as a (line, line_ending) tuple. If the line does not fit
            into self.buffer_size, line_ending is empty and the rest of the line
            is returned with the next iteration.
        &#34;&#34;&#34;
        read = self.stream.read
        maxread, maxbuf = self.content_length, self.buffer_size
        buffer = b&#34;&#34;  # buffer for the last (partial) line

        while True:
            data = read(maxbuf if maxread &lt; 0 else min(maxbuf, maxread))
            maxread -= len(data)
            lines = (buffer + data).splitlines(True)
            len_first_line = len(lines[0])

            # be sure that the first line does not become too big
            if len_first_line &gt; self.buffer_size:
                # at the same time don&#39;t split a &#39;\r\n&#39; accidentally
                if len_first_line == self.buffer_size + 1 and lines[0].endswith(b&#34;\r\n&#34;):
                    splitpos = self.buffer_size - 1
                else:
                    splitpos = self.buffer_size
                lines[:1] = [lines[0][:splitpos], lines[0][splitpos:]]

            if data:
                buffer = lines[-1]
                lines = lines[:-1]

            for line in lines:
                if line.endswith(b&#34;\r\n&#34;):
                    yield line[:-2], b&#34;\r\n&#34;
                elif line.endswith(b&#34;\n&#34;):
                    yield line[:-1], b&#34;\n&#34;
                elif line.endswith(b&#34;\r&#34;):
                    yield line[:-1], b&#34;\r&#34;
                else:
                    yield line, b&#34;&#34;

            if not data:
                break

    def _iterparse(self):
        lines, line = self._lineiter(), &#34;&#34;
        separator = b&#34;--&#34; + to_bytes(self.boundary)
        terminator = b&#34;--&#34; + to_bytes(self.boundary) + b&#34;--&#34;

        # Consume first boundary. Ignore any preamble, as required by RFC
        # 2046, section 5.1.1.
        for line, nl in lines:
            if line in (separator, terminator):
                break
        else:
            raise MultipartError(&#34;Stream does not contain boundary&#34;)

        # Check for empty data
        if line == terminator:
            for _ in lines:
                raise MultipartError(&#34;Data after end of stream&#34;)
            return

        # For each part in stream...
        mem_used, disk_used = 0, 0  # Track used resources to prevent DoS
        is_tail = False  # True if the last line was incomplete (cutted)

        opts = {
            &#34;buffer_size&#34;: self.buffer_size,
            &#34;memfile_limit&#34;: self.memfile_limit,
            &#34;charset&#34;: self.charset,
        }

        part = MultipartPart(**opts)

        for line, nl in lines:
            if line == terminator and not is_tail:
                part.file.seek(0)
                yield part
                break

            elif line == separator and not is_tail:
                if part.is_buffered():
                    mem_used += part.size
                else:
                    disk_used += part.size
                part.file.seek(0)

                yield part

                part = MultipartPart(**opts)

            else:
                is_tail = not nl  # The next line continues this one
                try:
                    part.feed(line, nl)

                    if part.is_buffered():
                        if part.size + mem_used &gt; self.mem_limit:
                            raise MultipartError(&#34;Memory limit reached.&#34;)
                    elif part.size + disk_used &gt; self.disk_limit:
                        raise MultipartError(&#34;Disk limit reached.&#34;)
                except MultipartError:
                    part.close()
                    raise
        else:
            # If we run off the end of the loop, the current MultipartPart
            # will not have been yielded, so it&#39;s our responsibility to
            # close it.
            part.close()

        if line != terminator:
            raise MultipartError(&#34;Unexpected end of multipart stream.&#34;)


class MultipartPart(object):
    def __init__(self, buffer_size=2 ** 16, memfile_limit=2 ** 18, charset=&#34;latin1&#34;):
        self.headerlist = []
        self.headers = None
        self.file = False
        self.size = 0
        self._buf = b&#34;&#34;
        self.disposition = None
        self.name = None
        self.filename = None
        self.content_type = None
        self.charset = charset
        self.memfile_limit = memfile_limit
        self.buffer_size = buffer_size

    def feed(self, line, nl=&#34;&#34;):
        if self.file:
            return self.write_body(line, nl)

        return self.write_header(line, nl)

    def write_header(self, line, nl):
        line = line.decode(self.charset)

        if not nl:
            raise MultipartError(&#34;Unexpected end of line in header.&#34;)

        if not line.strip():  # blank line -&gt; end of header segment
            self.finish_header()
        elif line[0] in &#34; \t&#34; and self.headerlist:
            name, value = self.headerlist.pop()
            self.headerlist.append((name, value + line.strip()))
        else:
            if &#34;:&#34; not in line:
                raise MultipartError(&#34;Syntax error in header: No colon.&#34;)

            name, value = line.split(&#34;:&#34;, 1)
            self.headerlist.append((name.strip(), value.strip()))

    def write_body(self, line, nl):
        if not line and not nl:
            return  # This does not even flush the buffer

        self.size += len(line) + len(self._buf)
        self.file.write(self._buf + line)
        self._buf = nl

        if self.content_length &gt; 0 and self.size &gt; self.content_length:
            raise MultipartError(&#34;Size of body exceeds Content-Length header.&#34;)

        if self.size &gt; self.memfile_limit and isinstance(self.file, BytesIO):
            # TODO: What about non-file uploads that exceed the memfile_limit?
            self.file, old = TemporaryFile(mode=&#34;w+b&#34;), self.file
            old.seek(0)
            copy_file(old, self.file, self.size, self.buffer_size)

    def finish_header(self):
        self.file = BytesIO()
        self.headers = Headers(self.headerlist)
        content_disposition = self.headers.get(&#34;Content-Disposition&#34;, &#34;&#34;)
        content_type = self.headers.get(&#34;Content-Type&#34;, &#34;&#34;)

        if not content_disposition:
            raise MultipartError(&#34;Content-Disposition header is missing.&#34;)

        self.disposition, self.options = parse_options_header(content_disposition)
        self.name = self.options.get(&#34;name&#34;)
        self.filename = self.options.get(&#34;filename&#34;)
        self.content_type, options = parse_options_header(content_type)
        self.charset = options.get(&#34;charset&#34;) or self.charset
        self.content_length = int(self.headers.get(&#34;Content-Length&#34;, &#34;-1&#34;))

    def is_buffered(self):
        &#34;&#34;&#34; Return true if the data is fully buffered in memory.&#34;&#34;&#34;
        return isinstance(self.file, BytesIO)

    @property
    def value(self):
        &#34;&#34;&#34; Data decoded with the specified charset &#34;&#34;&#34;

        return self.raw.decode(self.charset)

    @property
    def raw(self):
        &#34;&#34;&#34; Data without decoding &#34;&#34;&#34;
        pos = self.file.tell()
        self.file.seek(0)

        try:
            val = self.file.read()
        except IOError:
            raise
        finally:
            self.file.seek(pos)

        return val

    def save_as(self, path):
        with open(path, &#34;wb&#34;) as fp:
            pos = self.file.tell()

            try:
                self.file.seek(0)
                size = copy_file(self.file, fp)
            finally:
                self.file.seek(pos)

        return size

    def close(self):
        if self.file:
            self.file.close()
            self.file = False


##############################################################################
#################################### WSGI ####################################
##############################################################################


def parse_form_data(environ, charset=&#34;utf8&#34;, strict=False, **kwargs):
    &#34;&#34;&#34; Parse form data from an environ dict and return a (forms, files) tuple.
        Both tuple values are dictionaries with the form-field name as a key
        (unicode) and lists as values (multiple values per key are possible).
        The forms-dictionary contains form-field values as unicode strings.
        The files-dictionary contains :class:`MultipartPart` instances, either
        because the form-field was a file-upload or the value is too big to fit
        into memory limits.

        :param environ: An WSGI environment dict.
        :param charset: The charset to use if unsure. (default: utf8)
        :param strict: If True, raise :exc:`MultipartError` on any parsing
                       errors. These are silently ignored by default.
    &#34;&#34;&#34;

    forms, files = MultiDict(), MultiDict()

    try:
        if environ.get(&#34;REQUEST_METHOD&#34;, &#34;GET&#34;).upper() not in (&#34;POST&#34;, &#34;PUT&#34;):
            raise MultipartError(&#34;Request method other than POST or PUT.&#34;)
        content_length = int(environ.get(&#34;CONTENT_LENGTH&#34;, &#34;-1&#34;))
        content_type = environ.get(&#34;CONTENT_TYPE&#34;, &#34;&#34;)

        if not content_type:
            raise MultipartError(&#34;Missing Content-Type header.&#34;)

        content_type, options = parse_options_header(content_type)
        stream = environ.get(&#34;wsgi.input&#34;) or BytesIO()
        kwargs[&#34;charset&#34;] = charset = options.get(&#34;charset&#34;, charset)

        if content_type == &#34;multipart/form-data&#34;:
            boundary = options.get(&#34;boundary&#34;, &#34;&#34;)

            if not boundary:
                raise MultipartError(&#34;No boundary for multipart/form-data.&#34;)

            for part in MultipartParser(stream, boundary, content_length, **kwargs):
                if part.filename or not part.is_buffered():
                    files[part.name] = part
                else:  # TODO: Big form-fields are in the files dict. really?
                    forms[part.name] = part.value

        elif content_type in (
            &#34;application/x-www-form-urlencoded&#34;,
            &#34;application/x-url-encoded&#34;,
        ):
            mem_limit = kwargs.get(&#34;mem_limit&#34;, 2 ** 20)
            if content_length &gt; mem_limit:
                raise MultipartError(&#34;Request too big. Increase MAXMEM.&#34;)

            data = stream.read(mem_limit).decode(charset)

            if stream.read(1):  # These is more that does not fit mem_limit
                raise MultipartError(&#34;Request too big. Increase MAXMEM.&#34;)

            data = parse_qs(data, keep_blank_values=True, encoding=charset)

            for key, values in data.items():
                for value in values:
                    forms[key] = value
        else:
            raise MultipartError(&#34;Unsupported content type.&#34;)

    except MultipartError:
        if strict:
            for part in files.values():
                part.close()
            raise

    return forms, files</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Wsgi.multipart.parse_form_data"><code class="name flex">
<span>def <span class="ident">parse_form_data</span></span>(<span>environ, charset='utf8', strict=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse form data from an environ dict and return a (forms, files) tuple.
Both tuple values are dictionaries with the form-field name as a key
(unicode) and lists as values (multiple values per key are possible).
The forms-dictionary contains form-field values as unicode strings.
The files-dictionary contains :class:<code><a title="Wsgi.multipart.MultipartPart" href="#Wsgi.multipart.MultipartPart">MultipartPart</a></code> instances, either
because the form-field was a file-upload or the value is too big to fit
into memory limits.</p>
<p>:param environ: An WSGI environment dict.
:param charset: The charset to use if unsure. (default: utf8)
:param strict: If True, raise :exc:<code><a title="Wsgi.multipart.MultipartError" href="#Wsgi.multipart.MultipartError">MultipartError</a></code> on any parsing
errors. These are silently ignored by default.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_form_data(environ, charset=&#34;utf8&#34;, strict=False, **kwargs):
    &#34;&#34;&#34; Parse form data from an environ dict and return a (forms, files) tuple.
        Both tuple values are dictionaries with the form-field name as a key
        (unicode) and lists as values (multiple values per key are possible).
        The forms-dictionary contains form-field values as unicode strings.
        The files-dictionary contains :class:`MultipartPart` instances, either
        because the form-field was a file-upload or the value is too big to fit
        into memory limits.

        :param environ: An WSGI environment dict.
        :param charset: The charset to use if unsure. (default: utf8)
        :param strict: If True, raise :exc:`MultipartError` on any parsing
                       errors. These are silently ignored by default.
    &#34;&#34;&#34;

    forms, files = MultiDict(), MultiDict()

    try:
        if environ.get(&#34;REQUEST_METHOD&#34;, &#34;GET&#34;).upper() not in (&#34;POST&#34;, &#34;PUT&#34;):
            raise MultipartError(&#34;Request method other than POST or PUT.&#34;)
        content_length = int(environ.get(&#34;CONTENT_LENGTH&#34;, &#34;-1&#34;))
        content_type = environ.get(&#34;CONTENT_TYPE&#34;, &#34;&#34;)

        if not content_type:
            raise MultipartError(&#34;Missing Content-Type header.&#34;)

        content_type, options = parse_options_header(content_type)
        stream = environ.get(&#34;wsgi.input&#34;) or BytesIO()
        kwargs[&#34;charset&#34;] = charset = options.get(&#34;charset&#34;, charset)

        if content_type == &#34;multipart/form-data&#34;:
            boundary = options.get(&#34;boundary&#34;, &#34;&#34;)

            if not boundary:
                raise MultipartError(&#34;No boundary for multipart/form-data.&#34;)

            for part in MultipartParser(stream, boundary, content_length, **kwargs):
                if part.filename or not part.is_buffered():
                    files[part.name] = part
                else:  # TODO: Big form-fields are in the files dict. really?
                    forms[part.name] = part.value

        elif content_type in (
            &#34;application/x-www-form-urlencoded&#34;,
            &#34;application/x-url-encoded&#34;,
        ):
            mem_limit = kwargs.get(&#34;mem_limit&#34;, 2 ** 20)
            if content_length &gt; mem_limit:
                raise MultipartError(&#34;Request too big. Increase MAXMEM.&#34;)

            data = stream.read(mem_limit).decode(charset)

            if stream.read(1):  # These is more that does not fit mem_limit
                raise MultipartError(&#34;Request too big. Increase MAXMEM.&#34;)

            data = parse_qs(data, keep_blank_values=True, encoding=charset)

            for key, values in data.items():
                for value in values:
                    forms[key] = value
        else:
            raise MultipartError(&#34;Unsupported content type.&#34;)

    except MultipartError:
        if strict:
            for part in files.values():
                part.close()
            raise

    return forms, files</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Wsgi.multipart.MultipartError"><code class="flex name class">
<span>class <span class="ident">MultipartError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Inappropriate argument value (of correct type).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultipartError(ValueError):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="Wsgi.multipart.MultipartParser"><code class="flex name class">
<span>class <span class="ident">MultipartParser</span></span>
<span>(</span><span>stream, boundary, content_length=-1, disk_limit=1073741824, mem_limit=1048576, memfile_limit=262144, buffer_size=65536, charset='latin1')</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a multipart/form-data byte stream. This object is an iterator
over the parts of the message.</p>
<p>:param stream: A file-like stream. Must implement <code>.read(size)</code>.
:param boundary: The multipart boundary as a byte string.
:param content_length: The maximum number of bytes to read.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultipartParser(object):
    def __init__(
        self,
        stream,
        boundary,
        content_length=-1,
        disk_limit=2 ** 30,
        mem_limit=2 ** 20,
        memfile_limit=2 ** 18,
        buffer_size=2 ** 16,
        charset=&#34;latin1&#34;,
    ):
        &#34;&#34;&#34; Parse a multipart/form-data byte stream. This object is an iterator
            over the parts of the message.

            :param stream: A file-like stream. Must implement ``.read(size)``.
            :param boundary: The multipart boundary as a byte string.
            :param content_length: The maximum number of bytes to read.
        &#34;&#34;&#34;
        self.stream = stream
        self.boundary = boundary
        self.content_length = content_length
        self.disk_limit = disk_limit
        self.memfile_limit = memfile_limit
        self.mem_limit = min(mem_limit, self.disk_limit)
        self.buffer_size = min(buffer_size, self.mem_limit)
        self.charset = charset

        if self.buffer_size - 6 &lt; len(boundary):  # &#34;--boundary--\r\n&#34;
            raise MultipartError(&#34;Boundary does not fit into buffer_size.&#34;)

        self._done = []
        self._part_iter = None

    def __iter__(self):
        &#34;&#34;&#34; Iterate over the parts of the multipart message. &#34;&#34;&#34;
        if not self._part_iter:
            self._part_iter = self._iterparse()

        for part in self._done:
            yield part

        for part in self._part_iter:
            self._done.append(part)
            yield part

    def parts(self):
        &#34;&#34;&#34; Returns a list with all parts of the multipart message. &#34;&#34;&#34;
        return list(self)

    def get(self, name, default=None):
        &#34;&#34;&#34; Return the first part with that name or a default value (None). &#34;&#34;&#34;
        for part in self:
            if name == part.name:
                return part

        return default

    def get_all(self, name):
        &#34;&#34;&#34; Return a list of parts with that name. &#34;&#34;&#34;
        return [p for p in self if p.name == name]

    def _lineiter(self):
        &#34;&#34;&#34; Iterate over a binary file-like object line by line. Each line is
            returned as a (line, line_ending) tuple. If the line does not fit
            into self.buffer_size, line_ending is empty and the rest of the line
            is returned with the next iteration.
        &#34;&#34;&#34;
        read = self.stream.read
        maxread, maxbuf = self.content_length, self.buffer_size
        buffer = b&#34;&#34;  # buffer for the last (partial) line

        while True:
            data = read(maxbuf if maxread &lt; 0 else min(maxbuf, maxread))
            maxread -= len(data)
            lines = (buffer + data).splitlines(True)
            len_first_line = len(lines[0])

            # be sure that the first line does not become too big
            if len_first_line &gt; self.buffer_size:
                # at the same time don&#39;t split a &#39;\r\n&#39; accidentally
                if len_first_line == self.buffer_size + 1 and lines[0].endswith(b&#34;\r\n&#34;):
                    splitpos = self.buffer_size - 1
                else:
                    splitpos = self.buffer_size
                lines[:1] = [lines[0][:splitpos], lines[0][splitpos:]]

            if data:
                buffer = lines[-1]
                lines = lines[:-1]

            for line in lines:
                if line.endswith(b&#34;\r\n&#34;):
                    yield line[:-2], b&#34;\r\n&#34;
                elif line.endswith(b&#34;\n&#34;):
                    yield line[:-1], b&#34;\n&#34;
                elif line.endswith(b&#34;\r&#34;):
                    yield line[:-1], b&#34;\r&#34;
                else:
                    yield line, b&#34;&#34;

            if not data:
                break

    def _iterparse(self):
        lines, line = self._lineiter(), &#34;&#34;
        separator = b&#34;--&#34; + to_bytes(self.boundary)
        terminator = b&#34;--&#34; + to_bytes(self.boundary) + b&#34;--&#34;

        # Consume first boundary. Ignore any preamble, as required by RFC
        # 2046, section 5.1.1.
        for line, nl in lines:
            if line in (separator, terminator):
                break
        else:
            raise MultipartError(&#34;Stream does not contain boundary&#34;)

        # Check for empty data
        if line == terminator:
            for _ in lines:
                raise MultipartError(&#34;Data after end of stream&#34;)
            return

        # For each part in stream...
        mem_used, disk_used = 0, 0  # Track used resources to prevent DoS
        is_tail = False  # True if the last line was incomplete (cutted)

        opts = {
            &#34;buffer_size&#34;: self.buffer_size,
            &#34;memfile_limit&#34;: self.memfile_limit,
            &#34;charset&#34;: self.charset,
        }

        part = MultipartPart(**opts)

        for line, nl in lines:
            if line == terminator and not is_tail:
                part.file.seek(0)
                yield part
                break

            elif line == separator and not is_tail:
                if part.is_buffered():
                    mem_used += part.size
                else:
                    disk_used += part.size
                part.file.seek(0)

                yield part

                part = MultipartPart(**opts)

            else:
                is_tail = not nl  # The next line continues this one
                try:
                    part.feed(line, nl)

                    if part.is_buffered():
                        if part.size + mem_used &gt; self.mem_limit:
                            raise MultipartError(&#34;Memory limit reached.&#34;)
                    elif part.size + disk_used &gt; self.disk_limit:
                        raise MultipartError(&#34;Disk limit reached.&#34;)
                except MultipartError:
                    part.close()
                    raise
        else:
            # If we run off the end of the loop, the current MultipartPart
            # will not have been yielded, so it&#39;s our responsibility to
            # close it.
            part.close()

        if line != terminator:
            raise MultipartError(&#34;Unexpected end of multipart stream.&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Wsgi.multipart.MultipartParser.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, name, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the first part with that name or a default value (None).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, name, default=None):
    &#34;&#34;&#34; Return the first part with that name or a default value (None). &#34;&#34;&#34;
    for part in self:
        if name == part.name:
            return part

    return default</code></pre>
</details>
</dd>
<dt id="Wsgi.multipart.MultipartParser.get_all"><code class="name flex">
<span>def <span class="ident">get_all</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of parts with that name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all(self, name):
    &#34;&#34;&#34; Return a list of parts with that name. &#34;&#34;&#34;
    return [p for p in self if p.name == name]</code></pre>
</details>
</dd>
<dt id="Wsgi.multipart.MultipartParser.parts"><code class="name flex">
<span>def <span class="ident">parts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list with all parts of the multipart message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parts(self):
    &#34;&#34;&#34; Returns a list with all parts of the multipart message. &#34;&#34;&#34;
    return list(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Wsgi.multipart.MultipartPart"><code class="flex name class">
<span>class <span class="ident">MultipartPart</span></span>
<span>(</span><span>buffer_size=65536, memfile_limit=262144, charset='latin1')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultipartPart(object):
    def __init__(self, buffer_size=2 ** 16, memfile_limit=2 ** 18, charset=&#34;latin1&#34;):
        self.headerlist = []
        self.headers = None
        self.file = False
        self.size = 0
        self._buf = b&#34;&#34;
        self.disposition = None
        self.name = None
        self.filename = None
        self.content_type = None
        self.charset = charset
        self.memfile_limit = memfile_limit
        self.buffer_size = buffer_size

    def feed(self, line, nl=&#34;&#34;):
        if self.file:
            return self.write_body(line, nl)

        return self.write_header(line, nl)

    def write_header(self, line, nl):
        line = line.decode(self.charset)

        if not nl:
            raise MultipartError(&#34;Unexpected end of line in header.&#34;)

        if not line.strip():  # blank line -&gt; end of header segment
            self.finish_header()
        elif line[0] in &#34; \t&#34; and self.headerlist:
            name, value = self.headerlist.pop()
            self.headerlist.append((name, value + line.strip()))
        else:
            if &#34;:&#34; not in line:
                raise MultipartError(&#34;Syntax error in header: No colon.&#34;)

            name, value = line.split(&#34;:&#34;, 1)
            self.headerlist.append((name.strip(), value.strip()))

    def write_body(self, line, nl):
        if not line and not nl:
            return  # This does not even flush the buffer

        self.size += len(line) + len(self._buf)
        self.file.write(self._buf + line)
        self._buf = nl

        if self.content_length &gt; 0 and self.size &gt; self.content_length:
            raise MultipartError(&#34;Size of body exceeds Content-Length header.&#34;)

        if self.size &gt; self.memfile_limit and isinstance(self.file, BytesIO):
            # TODO: What about non-file uploads that exceed the memfile_limit?
            self.file, old = TemporaryFile(mode=&#34;w+b&#34;), self.file
            old.seek(0)
            copy_file(old, self.file, self.size, self.buffer_size)

    def finish_header(self):
        self.file = BytesIO()
        self.headers = Headers(self.headerlist)
        content_disposition = self.headers.get(&#34;Content-Disposition&#34;, &#34;&#34;)
        content_type = self.headers.get(&#34;Content-Type&#34;, &#34;&#34;)

        if not content_disposition:
            raise MultipartError(&#34;Content-Disposition header is missing.&#34;)

        self.disposition, self.options = parse_options_header(content_disposition)
        self.name = self.options.get(&#34;name&#34;)
        self.filename = self.options.get(&#34;filename&#34;)
        self.content_type, options = parse_options_header(content_type)
        self.charset = options.get(&#34;charset&#34;) or self.charset
        self.content_length = int(self.headers.get(&#34;Content-Length&#34;, &#34;-1&#34;))

    def is_buffered(self):
        &#34;&#34;&#34; Return true if the data is fully buffered in memory.&#34;&#34;&#34;
        return isinstance(self.file, BytesIO)

    @property
    def value(self):
        &#34;&#34;&#34; Data decoded with the specified charset &#34;&#34;&#34;

        return self.raw.decode(self.charset)

    @property
    def raw(self):
        &#34;&#34;&#34; Data without decoding &#34;&#34;&#34;
        pos = self.file.tell()
        self.file.seek(0)

        try:
            val = self.file.read()
        except IOError:
            raise
        finally:
            self.file.seek(pos)

        return val

    def save_as(self, path):
        with open(path, &#34;wb&#34;) as fp:
            pos = self.file.tell()

            try:
                self.file.seek(0)
                size = copy_file(self.file, fp)
            finally:
                self.file.seek(pos)

        return size

    def close(self):
        if self.file:
            self.file.close()
            self.file = False</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="Wsgi.multipart.MultipartPart.raw"><code class="name">var <span class="ident">raw</span></code></dt>
<dd>
<div class="desc"><p>Data without decoding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw(self):
    &#34;&#34;&#34; Data without decoding &#34;&#34;&#34;
    pos = self.file.tell()
    self.file.seek(0)

    try:
        val = self.file.read()
    except IOError:
        raise
    finally:
        self.file.seek(pos)

    return val</code></pre>
</details>
</dd>
<dt id="Wsgi.multipart.MultipartPart.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>Data decoded with the specified charset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self):
    &#34;&#34;&#34; Data decoded with the specified charset &#34;&#34;&#34;

    return self.raw.decode(self.charset)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Wsgi.multipart.MultipartPart.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    if self.file:
        self.file.close()
        self.file = False</code></pre>
</details>
</dd>
<dt id="Wsgi.multipart.MultipartPart.feed"><code class="name flex">
<span>def <span class="ident">feed</span></span>(<span>self, line, nl='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def feed(self, line, nl=&#34;&#34;):
    if self.file:
        return self.write_body(line, nl)

    return self.write_header(line, nl)</code></pre>
</details>
</dd>
<dt id="Wsgi.multipart.MultipartPart.finish_header"><code class="name flex">
<span>def <span class="ident">finish_header</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish_header(self):
    self.file = BytesIO()
    self.headers = Headers(self.headerlist)
    content_disposition = self.headers.get(&#34;Content-Disposition&#34;, &#34;&#34;)
    content_type = self.headers.get(&#34;Content-Type&#34;, &#34;&#34;)

    if not content_disposition:
        raise MultipartError(&#34;Content-Disposition header is missing.&#34;)

    self.disposition, self.options = parse_options_header(content_disposition)
    self.name = self.options.get(&#34;name&#34;)
    self.filename = self.options.get(&#34;filename&#34;)
    self.content_type, options = parse_options_header(content_type)
    self.charset = options.get(&#34;charset&#34;) or self.charset
    self.content_length = int(self.headers.get(&#34;Content-Length&#34;, &#34;-1&#34;))</code></pre>
</details>
</dd>
<dt id="Wsgi.multipart.MultipartPart.is_buffered"><code class="name flex">
<span>def <span class="ident">is_buffered</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if the data is fully buffered in memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_buffered(self):
    &#34;&#34;&#34; Return true if the data is fully buffered in memory.&#34;&#34;&#34;
    return isinstance(self.file, BytesIO)</code></pre>
</details>
</dd>
<dt id="Wsgi.multipart.MultipartPart.save_as"><code class="name flex">
<span>def <span class="ident">save_as</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_as(self, path):
    with open(path, &#34;wb&#34;) as fp:
        pos = self.file.tell()

        try:
            self.file.seek(0)
            size = copy_file(self.file, fp)
        finally:
            self.file.seek(pos)

    return size</code></pre>
</details>
</dd>
<dt id="Wsgi.multipart.MultipartPart.write_body"><code class="name flex">
<span>def <span class="ident">write_body</span></span>(<span>self, line, nl)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_body(self, line, nl):
    if not line and not nl:
        return  # This does not even flush the buffer

    self.size += len(line) + len(self._buf)
    self.file.write(self._buf + line)
    self._buf = nl

    if self.content_length &gt; 0 and self.size &gt; self.content_length:
        raise MultipartError(&#34;Size of body exceeds Content-Length header.&#34;)

    if self.size &gt; self.memfile_limit and isinstance(self.file, BytesIO):
        # TODO: What about non-file uploads that exceed the memfile_limit?
        self.file, old = TemporaryFile(mode=&#34;w+b&#34;), self.file
        old.seek(0)
        copy_file(old, self.file, self.size, self.buffer_size)</code></pre>
</details>
</dd>
<dt id="Wsgi.multipart.MultipartPart.write_header"><code class="name flex">
<span>def <span class="ident">write_header</span></span>(<span>self, line, nl)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_header(self, line, nl):
    line = line.decode(self.charset)

    if not nl:
        raise MultipartError(&#34;Unexpected end of line in header.&#34;)

    if not line.strip():  # blank line -&gt; end of header segment
        self.finish_header()
    elif line[0] in &#34; \t&#34; and self.headerlist:
        name, value = self.headerlist.pop()
        self.headerlist.append((name, value + line.strip()))
    else:
        if &#34;:&#34; not in line:
            raise MultipartError(&#34;Syntax error in header: No colon.&#34;)

        name, value = line.split(&#34;:&#34;, 1)
        self.headerlist.append((name.strip(), value.strip()))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#parser-for-multipartform-data">Parser for multipart/form-data</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Wsgi" href="index.html">Wsgi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Wsgi.multipart.parse_form_data" href="#Wsgi.multipart.parse_form_data">parse_form_data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Wsgi.multipart.MultipartError" href="#Wsgi.multipart.MultipartError">MultipartError</a></code></h4>
</li>
<li>
<h4><code><a title="Wsgi.multipart.MultipartParser" href="#Wsgi.multipart.MultipartParser">MultipartParser</a></code></h4>
<ul class="">
<li><code><a title="Wsgi.multipart.MultipartParser.get" href="#Wsgi.multipart.MultipartParser.get">get</a></code></li>
<li><code><a title="Wsgi.multipart.MultipartParser.get_all" href="#Wsgi.multipart.MultipartParser.get_all">get_all</a></code></li>
<li><code><a title="Wsgi.multipart.MultipartParser.parts" href="#Wsgi.multipart.MultipartParser.parts">parts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Wsgi.multipart.MultipartPart" href="#Wsgi.multipart.MultipartPart">MultipartPart</a></code></h4>
<ul class="two-column">
<li><code><a title="Wsgi.multipart.MultipartPart.close" href="#Wsgi.multipart.MultipartPart.close">close</a></code></li>
<li><code><a title="Wsgi.multipart.MultipartPart.feed" href="#Wsgi.multipart.MultipartPart.feed">feed</a></code></li>
<li><code><a title="Wsgi.multipart.MultipartPart.finish_header" href="#Wsgi.multipart.MultipartPart.finish_header">finish_header</a></code></li>
<li><code><a title="Wsgi.multipart.MultipartPart.is_buffered" href="#Wsgi.multipart.MultipartPart.is_buffered">is_buffered</a></code></li>
<li><code><a title="Wsgi.multipart.MultipartPart.raw" href="#Wsgi.multipart.MultipartPart.raw">raw</a></code></li>
<li><code><a title="Wsgi.multipart.MultipartPart.save_as" href="#Wsgi.multipart.MultipartPart.save_as">save_as</a></code></li>
<li><code><a title="Wsgi.multipart.MultipartPart.value" href="#Wsgi.multipart.MultipartPart.value">value</a></code></li>
<li><code><a title="Wsgi.multipart.MultipartPart.write_body" href="#Wsgi.multipart.MultipartPart.write_body">write_body</a></code></li>
<li><code><a title="Wsgi.multipart.MultipartPart.write_header" href="#Wsgi.multipart.MultipartPart.write_header">write_header</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>